package com.checker.vulnerabilitychecker;

import org.springframework.stereotype.Component;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.concurrent.Executors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

@Component
public class Checker
{
    public String getReport()
    {
        Path copiedTo;
        try {
            //copiedTo = getRepo();
            //String directoryName = unZip(copiedTo);
            check("singleDirectory");
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }

        //implement push the checked files to S3.
        return "NOT IMPLEMENTED YET";
    }

    public void check(String directory) throws IOException, InterruptedException
    {
        boolean isWindows = System.getProperty("os.name")
                .toLowerCase().startsWith("windows");
        ProcessBuilder builder = new ProcessBuilder();
        ProcessBuilder command2 = new ProcessBuilder();
        if (isWindows) {
            builder.command("cmd.exe", "/c", "spotbugs", "-textui",
                    "-conserveSpace", "-pluginList", "findsecbugs-plugin-1.11.0",
                    "-visitors", "CrossSiteScripting", "-nested:false", "-maxHeap", "2000",
                    "-xml", "-output", "xssbugs.xml", "./");

            command2.command("cmd.exe", "/c", "spotbugs", "-textui",
                    "-conserveSpace", "-pluginList", "findsecbugs-plugin-1.11.0",
                    "-visitors", "SqlInjectionDetector", "-nested:false", "-maxHeap", "2000",
                    "-xml", "-output", "sqlibugs.xml", "./");
        } else {
            builder.command("sh", "-c", "ls");
        }
        final File tmp = File.createTempFile("out", null);
        final File tmp1 = File.createTempFile("out1", null);
        String dir = directory;
        builder.redirectErrorStream(true).redirectOutput(tmp);
        builder.directory((new File("../clonedrepositories")));

        command2.directory((new File("../clonedrepositories")));
        command2.redirectErrorStream(true).redirectOutput(tmp1);

        Process process = builder.start();
        IOStreamConsumer consumer =
                new IOStreamConsumer(process.getInputStream(), System.out::println);
        Executors.newSingleThreadExecutor().submit(consumer);

        final int exitCode = process.waitFor();
        printToConsole(tmp);
        tmp.delete();

        Process process1 = command2.start();
        final int exitCode1 = process1.waitFor();
        printToConsole(tmp1);
        tmp1.delete();
    }

    private void printToConsole(File file) throws IOException //helper method to cmd
    {
        BufferedReader reader =
                new BufferedReader(new InputStreamReader(new FileInputStream(file)));
        String line = "";
        while ((line = reader.readLine()) != null)
        {
            System.out.println(line);
        }
        reader.close();
    }

    private Path getRepo() //get repository from s3 to local
    {
        File x = new File("../xd.zip");
        Path copied = Paths.get("./" + x.getName());
        Path originalPath = Paths.get("../xd.zip");
        try {
            Files.copy(originalPath, copied, StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return copied;
    }

    private String unZip(Path filePath) throws IOException
    {
        File x = new File(filePath.toString());
        String s = x.getName();
        String[] directoryName = s.split("\\.");
        File destination = new File("./" + directoryName[0]);
        byte[] buffer = new byte[1024];
        ZipInputStream zis = null;
        try {
            zis = new ZipInputStream(new FileInputStream(filePath.toString()));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        ZipEntry zipEntry = null;
        zipEntry = zis.getNextEntry();

        while (zipEntry != null) {
            File newFile = newFile(destination, zipEntry);
            if (zipEntry.isDirectory()) {
                if (!newFile.isDirectory() && !newFile.mkdirs()) {
                    throw new IOException("Failed to create directory " + newFile);
                }
            } else {
                // fix for Windows-created archives
                File parent = newFile.getParentFile();
                if (!parent.isDirectory() && !parent.mkdirs()) {
                    throw new IOException("Failed to create directory " + parent);
                }

                // write file content
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0) {
                    fos.write(buffer, 0, len);
                }
                fos.close();
            }
            zipEntry = zis.getNextEntry();
        }
        return directoryName[0];
    }

    private File newFile(File destinationDir, ZipEntry zipEntry) throws IOException //helper method to unzip
    {
        File destFile = new File(destinationDir, zipEntry.getName());

        String destDirPath = destinationDir.getCanonicalPath();
        String destFilePath = destFile.getCanonicalPath();

        if (!destFilePath.startsWith(destDirPath + File.separator)) {
            throw new IOException("Entry is outside of the target dir: " + zipEntry.getName());
        }

        return destFile;
    }
}
